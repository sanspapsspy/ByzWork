#include <iostream>
#include <cmath>

using namespace std;

// Макрос циклического сдвига влево на n бит
#define ROL(n, p, x) (((x) << (n)) | ((x) >> ((p) - (n))))

// Макрос циклического сдвига вправо на n бит
#define ROR(n, p, x) (((x) >> (n)) | ((x) << ((p) - (n))))

int main() {
    int p, n, x;

    cout << "Enter the number of bits (p): ";
    cin >> p;

    cout << "Enter the number of bits to shift (n): ";
    cin >> n;

    cout << "Enter the " << p << "-bit integer: ";
    cin >> x;

    cout << "Circular left shift by " << n << " bits: " << ROL(n, p, x) << endl;
    cout << "Circular right shift by " << n << " bits: " << ROR(n, p, x) << endl;

    return 0;
}
//1. Мы определяем два макроса : ROL(n, p, x) для циклического сдвига влево и ROR(n, p, x) для циклического сдвига вправо.
//2. Макрос ROL(n, p, x) работает следующим образом :
//-Число x сдвигается влево на n бит с помощью(x << n).
//- Остаток от деления x на 2 ^ p(т.е.младшие p - n битов) сдвигается вправо на p - n бит с помощью(x >> (p - n)).
//- Два этих результата соединяются с помощью побитового ИЛИ | , чтобы получить циклический сдвиг влево на n бит.
//3. Макрос ROR(n, p, x) работает аналогично, но сдвигает число вправо :
//-Число x сдвигается вправо на n бит с помощью(x >> n).
//- Остаток от деления x на 2 ^ (p - n) (т.е.старшие n битов) сдвигается влево на p - n бит с помощью(x << (p - n)).
//- Два этих результата соединяются с помощью побитового ИЛИ | , чтобы получить циклический сдвиг вправо на n бит.
//4. В main() мы запрашиваем у пользователя количество битов p, количество бит для сдвига n и само число x, затем используем макросы ROL() и ROR() для вывода результатов циклических сдвигов.